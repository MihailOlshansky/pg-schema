-- DuplicateRecordFields conflicts with singletons!
{-# LANGUAGE NoDuplicateRecordFields #-}
{-# LANGUAGE UndecidableInstances    #-}
{-# LANGUAGE UndecidableSuperClasses #-}
module Database.Schema.Def where

import Data.Set as S
import Data.Singletons.Prelude as SP
import Data.Singletons.TH
import Data.Text as T
import Util.ToStar


singletons [d|

  data TypDef' s = TypDef
    { typCategory :: s
    , typElem     :: Maybe s
    , typEnum     :: [s] }
    deriving Show

  data FldDef' s = FldDef
    { fdType        :: s
    , fdNullable    :: Bool
    , fdHasDefault  :: Bool }
    deriving Show

  data TabDef' s = TabDef
    { tdFlds       :: [s]
    , tdKey        :: [s]
    , tdUniq       :: [[s]] }
    deriving Show

  data RelDef' s = RelDef
    { rdFrom    :: s
    , rdTo      :: s
    , rdCols    :: [(s,s)] }
    deriving Show
  |]

type TypDefK = TypDef' Symbol
type FldDefK = FldDef' Symbol
type TabDefK = TabDef' Symbol
type RelDefK = RelDef' Symbol

type TypDef = TypDef' Text
type FldDef = FldDef' Text
type TabDef = TabDef' Text
type RelDef = RelDef' Text

-- CTypDef
-- | instances will be generated by TH
class
  (ToStar name, ToStar (TTypDef sch name))
  => CTypDef sch (name :: Symbol) where

  type TTypDef sch name :: TypDefK

  typName :: Text
  typName = toStar @_ @name

  typDef :: TypDef
  typDef = toStar @_ @(TTypDef sch name)

-- CFldDef
-- | instances will be generated by TH
class
  ( ToStar fname
  , ToStar (TFldDef sch tname fname)
  , CTypDef sch (FdType (TFldDef sch tname fname)) )
  => CFldDef sch tname (fname::Symbol) where
  type TFldDef sch tname fname :: FldDefK

  fldName :: Text
  fldName = toStar @_ @fname

  fldDef :: FldDef
  fldDef = toStar @_ @(TFldDef sch tname fname)

class
  ToStar (TFldDefs sch tname fnames)
  => CFldDefs sch tname (fnames::[Symbol]) where
  type TFldDefs sch tname fnames :: [FldDefK]

  fldDefs :: [FldDef]
  fldDefs = toStar @_ @(TFldDefs sch tname fnames)

instance CFldDefs sch tname '[] where
  type TFldDefs sch tname '[] = '[]

instance
  (CFldDef sch tname x, CFldDefs sch tname xs)
  => CFldDefs sch tname (x ': xs) where
  type TFldDefs sch tname (x ': xs) =
    TFldDef sch tname x ': TFldDefs sch tname xs

class
  ToStar (TFldDefs2 sch tname fnames)
  => CFldDefs2 sch tname (fnames::[[Symbol]]) where
  type TFldDefs2 sch tname fnames :: [[FldDefK]]

  fldDefs2 :: [[FldDef]]
  fldDefs2 = toStar @_ @(TFldDefs2 sch tname fnames)

instance CFldDefs2 sch tname '[] where
  type TFldDefs2 sch tname '[] = '[]

instance
  (CFldDefs sch tname x, CFldDefs2 sch tname xs)
  => CFldDefs2 sch tname (x ': xs) where
  type TFldDefs2 sch tname (x ': xs) =
    TFldDefs sch tname x ': TFldDefs2 sch tname xs

-- CTabDef
-- | instances will be generated by TH
class
  ( ToStar name, ToStar (TTabDef sch name)
  , CFldDefs sch name (TdFlds (TTabDef sch name))
  , CFldDefs sch name (TdKey (TTabDef sch name))
  , CFldDefs2 sch name (TdUniq (TTabDef sch name))
  ) => CTabDef sch (name::Symbol) where

  type TTabDef sch name :: TabDefK

  tabName :: Text
  tabName = toStar @_ @name

  tabDef :: TabDef
  tabDef = toStar @_ @(TTabDef sch name)

-- CRelDef
-- | instances will be generated by TH
class
  ( ToStar name, ToStar (TRelDef sch name)
  , CTabDef sch (TFromTab sch name)
  , CTabDef sch (TToTab sch name)
  , CFldDefs sch (TFromTab sch name) (TFromFlds sch name)
  , CFldDefs sch (TToTab sch name) (TToFlds sch name)
  )
  => CRelDef sch (name::Symbol) where

  type TRelDef sch name :: RelDefK

  relName :: T.Text
  relName = toStar @_ @name

  relDef :: RelDef
  relDef = toStar @_ @(TRelDef sch name)

type TFromTab sch name = RdFrom (TRelDef sch name)
type TFromFlds sch name = SP.Map FstSym0 (RdCols (TRelDef sch name))
type TToTab sch name = RdTo (TRelDef sch name)
type TToFlds sch name = SP.Map SndSym0 (RdCols (TRelDef sch name))

-- CSchema
class ToStar (TTabDefs sch names) => CTabDefs sch (names :: [Symbol]) where

  type TTabDefs sch names :: [TabDefK]

  tabDefs :: [TabDef]
  tabDefs = toStar @_ @(TTabDefs sch names)

instance CTabDefs sch '[] where
  type TTabDefs sch '[] = '[]

instance (CTabDef sch x, CTabDefs sch xs) => CTabDefs sch (x ': xs) where
  type TTabDefs sch (x ': xs) = TTabDef sch x ': TTabDefs sch xs
--
class ToStar (TRelDefs sch names) => CRelDefs sch (names :: [Symbol]) where

  type TRelDefs sch names :: [RelDefK]

  relDefs :: [RelDef]
  relDefs = toStar @_ @(TRelDefs sch names)

instance CRelDefs sch '[] where
  type TRelDefs sch '[] = '[]

instance (CRelDef sch x, CRelDefs sch xs) => CRelDefs sch (x ': xs) where
  type TRelDefs sch (x ': xs) = TRelDef sch x ': TRelDefs sch xs

-- | instances will be generated by TH
class
  ( ToStar (TSchema sch), ToStar (TTabs sch), ToStar (TRels sch)
  , CTabDefs sch (TTabs sch)
  , CRelDefs sch (TRels sch) )
  => CSchema sch where

  type TSchema sch  :: Symbol
  type TTabs sch    :: [Symbol]
  type TRels sch    :: [Symbol]

  schemaName :: Text
  schemaName = toStar @_ @(TSchema sch)

  tables :: S.Set T.Text
  tables = S.fromList (toStar @_ @(TTabs sch))

  rels :: S.Set T.Text
  rels = S.fromList (toStar @_ @(TRels sch))
