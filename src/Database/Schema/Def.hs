-- DuplicateRecordFields conflicts with singletons!
{-# LANGUAGE NoDuplicateRecordFields #-}
{-# LANGUAGE PolyKinds               #-}
{-# LANGUAGE UndecidableInstances    #-}
{-# LANGUAGE UndecidableSuperClasses #-}
module Database.Schema.Def where

import Data.Kind
import Data.List as L
import Data.Map as M
import Data.Set as S
import Data.Singletons.Prelude as SP
import Data.Singletons.TH
import Data.Text as T
import Util.ToStar


singletons [d|

  data TypDef' s = TypDef
    { typCategory :: s
    , typElem     :: Maybe s
    , typEnum     :: [s] }
    deriving Show

  data FldDef' s = FldDef
    { fdType        :: s
    , fdNullable    :: Bool
    , fdHasDefault  :: Bool }
    deriving Show

  data TabDef' s = TabDef
    { tdFlds       :: [s]
    , tdKey        :: [s]
    , tdUniq       :: [[s]] }
    deriving Show

  data RelDef' s = RelDef
    { rdFrom    :: s
    , rdTo      :: s
    , rdCols    :: [(s,s)] }
    deriving Show

  data KindName = Field | RelFrom | RelTo
  |]

type TypDefK = TypDef' Symbol
type FldDefK = FldDef' Symbol
type TabDefK = TabDef' Symbol
type RelDefK = RelDef' Symbol

type TypDef = TypDef' Text
type FldDef = FldDef' Text
type TabDef = TabDef' Text
type RelDef = RelDef' Text

-- CTypDef
-- | instances will be generated by TH
class
  (ToStar name, ToStar (TTypDef sch name))
  => CTypDef sch (name :: Symbol) where

  type TTypDef sch name :: TypDefK

  typName :: Text
  typName = toStar @_ @name

  typDef :: TypDef
  typDef = toStar @_ @(TTypDef sch name)

-- CFldDef
-- | instances will be generated by TH
class
  ( ToStar fname, ToStar tname
  , ToStar (TFldDef sch tname fname)
  , CTypDef sch (FdType (TFldDef sch tname fname)) )
  => CFldDef sch (tname::Symbol) (fname::Symbol) where
  type TFldDef sch tname fname :: FldDefK

  fldName :: Text
  fldName = toStar @_ @fname

  fldDef :: FldDef
  fldDef = toStar @_ @(TFldDef sch tname fname)

type family TDefs t k :: Type

type instance TDefs FldDef Symbol = FldDef
type instance TDefs TabDef Symbol = TabDef
type instance TDefs RelDef Symbol = RelDef

type instance TDefs t [k] = [TDefs t k]

class CDefs t par (fnames :: k) where
  defs :: TDefs t k

instance CFldDef sch tname x => CDefs FldDef '(sch, tname) x where
  defs = fldDef @sch @tname @x

instance CTabDef sch x => CDefs TabDef sch x where
  defs = tabDef @sch @x

instance CRelDef sch x => CDefs RelDef sch x where
  defs = relDef @sch @x

instance CDefs t par ('[] :: [k]) where
  defs = []

instance
  ( CDefs t par (x::k), CDefs t par (xs::[k]) )
  => CDefs t par (x ': xs) where
  defs = defs @t @par @x : defs @t @par @xs

-- CTabDef
-- | instances will be generated by TH
class
  ( ToStar name, ToStar (TTabDef sch name)
  , CDefs FldDef '(sch, name) (TdFlds (TTabDef sch name))
  , CDefs FldDef '(sch, name) (TdKey (TTabDef sch name))
  , CDefs FldDef '(sch, name) (TdUniq (TTabDef sch name))
  ) => CTabDef sch (name::Symbol) where

  type TTabDef sch name :: TabDefK

  tabName :: Text
  tabName = toStar @_ @name

  tabDef :: TabDef
  tabDef = toStar @_ @(TTabDef sch name)

-- CRelDef
-- | instances will be generated by TH
class
  ( ToStar name, ToStar (TRelDef sch name)
  , CTabDef sch (TFromTab sch name)
  , CTabDef sch (TToTab sch name)
  , CDefs FldDef '(sch, TFromTab sch name) (TFromFlds sch name)
  , CDefs FldDef '(sch, TToTab sch name) (TToFlds sch name)
  )
  => CRelDef sch (name::Symbol) where

  type TRelDef sch name :: RelDefK

  relName :: Text
  relName = toStar @_ @name

  relDef :: RelDef
  relDef = toStar @_ @(TRelDef sch name)

type TFromTab sch name = RdFrom (TRelDef sch name)
type TFromFlds sch name = SP.Map FstSym0 (RdCols (TRelDef sch name))
type TToTab sch name = RdTo (TRelDef sch name)
type TToFlds sch name = SP.Map SndSym0 (RdCols (TRelDef sch name))

-- | instances will be generated by TH
class
  ( ToStar (TSchema sch), ToStar (TTabs sch), ToStar (TRels sch)
  , CDefs TabDef sch (TTabs sch)
  , CDefs RelDef sch (TRels sch) )
  => CSchema sch where

  type TSchema sch  :: Symbol
  type TTabs sch    :: [Symbol]
  type TRels sch    :: [Symbol]

schemaName :: forall sch. CSchema sch => Text
schemaName = toStar @_ @(TSchema sch)

tabDefMap :: forall sch. CSchema sch => M.Map Text TabDef
tabDefMap = M.fromList $ L.zip (tables @sch) $ defs @TabDef @sch @(TTabs sch)

tables :: forall sch. CSchema sch => [Text]
tables = toStar @_ @(TTabs sch)

tabSet :: forall sch. CSchema sch => Set Text
tabSet = S.fromList $ tables @sch
--
relDefMap :: forall sch. CSchema sch => M.Map Text RelDef
relDefMap = M.fromList $ L.zip (rels @sch) $ defs @RelDef @sch @(TRels sch)

rels :: forall sch. CSchema sch => [Text]
rels = toStar @_ @(TRels sch)

relSet :: forall sch. CSchema sch => Set Text
relSet = S.fromList $ rels @sch
