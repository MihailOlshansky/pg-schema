{-# LANGUAGE UndecidableInstances    #-}
{-# LANGUAGE UndecidableSuperClasses #-}
module Database.Schema.Rec where

import Data.Aeson
import Data.Kind
import Data.Singletons.Prelude as SP
import Data.Singletons.TH
import Data.Text (Text)
import Database.PostgreSQL.Simple.FromField as PG
import Database.Schema.Def
import Type.Reflection
import Util.ToStar


singletons [d|
  data FldKind
    = FldPlain -- ^ simple field
    | FldTo    -- ^ other records referenced to this field (type is List)
    | FldFrom  -- ^ field point to another record
    deriving (Show, Read, Eq)

  data FieldInfo' s = FieldInfo
    { fieldKind :: FldKind
    , fieldName :: s
    , fieldDbName :: s }
    deriving Show

  |]

type FieldInfoK = FieldInfo' Symbol
type FieldInfo = FieldInfo' Text

-- | instances will be generated by TH
class CFieldType (r :: Type) (n :: Symbol) where
  type TFieldType r n :: Type

-- | instances will be generated by TH
class ToStar (TRecordInfo r) => CRecordInfo r where
  type TRecordInfo r :: [FieldInfoK]

recordInfo :: forall r. CRecordInfo r => [FieldInfo]
recordInfo = toStar @_ @(TRecordInfo r)

newtype SchList a = SchList { getSchList :: [a] }
  deriving (Show, Eq, Ord, FromJSON, ToJSON, Functor)

instance (FromJSON a, Typeable a) => FromField (SchList a) where
  fromField = fromJSONField

data QueryRecord = QueryRecord
  { tableName   :: Text
  , queryFields :: [QueryField] }
  deriving Show

data QueryRef = QueryRef
  { fromName :: Text
  , fromDef  :: FldDef
  , toName   :: Text
  , toDef    :: FldDef }
  deriving Show

data QueryField
  = FieldPlain Text Text FldDef
  | FieldTo    Text QueryRecord [QueryRef]
  | FieldFrom  Text QueryRecord [QueryRef]
  deriving Show

-- | instances will be generated by TH (with default method)
class
  (CSchema sch, ToStar t, CQueryFields db sch t r (TRecordInfo r))
  => CQueryRecord (db::Type) (sch::Type) (t::Symbol) (r::Type) where
  getQueryRecord :: QueryRecord
  getQueryRecord = QueryRecord {..}
    where
      tableName = toStar @_ @t
      queryFields = getQueryFields @db @sch @t @r @(TRecordInfo r)

class CTypDef sch tn => CanConvert db sch (tn::Symbol) (nullable::Bool) t

class
  (CSchema sch, CTabDef sch t)
  => CQueryFields db sch t r (fis :: [FieldInfoK]) where
 getQueryFields :: [QueryField]

instance (CSchema sch, CTabDef sch t) => CQueryFields db sch t r '[] where
  getQueryFields = []

instance
  ( CQueryFields db sch t r xs
  , CFldDef sch t dbname
  , fdef ~ TFldDef sch t dbname
  , CanConvert db sch (FdType fdef) (FdNullable fdef) (TFieldType r n)
  , ToStar n
  )
  => CQueryFields db sch t r ('FieldInfo 'FldPlain n dbname ': xs) where
  getQueryFields =
    FieldPlain (toStar @_ @n) (toStar @_ @dbname) (fldDef @sch @t @dbname)
      : getQueryFields @db @sch @t @r @xs

instance
  ( CQueryFields db sch t r xs
  , relDef ~ TRelDef sch dbname
  , tabTo ~ RdTo relDef
  , recTo ~ TFieldType r n
  , CQueryRecord db sch tabTo recTo
  , cols ~ RdCols relDef
  , ToStar cols
  , uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Fst uncols)
  , fdsTo ~ SP.Map (TFldDefSym2 sch tabTo) (Snd uncols)
  , ToStar fds
  , ToStar fdsTo
  , ToStar n
  )
  => CQueryFields db sch t r ('FieldInfo 'FldFrom n dbname ': xs) where
  getQueryFields =
    FieldFrom
      (toStar @_ @n)
      (getQueryRecord @db @sch @tabTo @recTo)
      refs
      : getQueryFields @db @sch @t @r @xs
    where
      refs =
        zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
          (toStar @_ @cols)
          (toStar @_ @fds)
          (toStar @_ @fdsTo)

instance
  ( CQueryFields db sch t r xs
  , relDef ~ TRelDef sch dbname
  , tabFrom ~ RdFrom relDef
  , recFrom ~ TFieldType r n
  , CQueryRecord db sch tabFrom recFrom
  , cols ~ RdCols relDef
  , ToStar cols
  , uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Snd uncols)
  , fdsFrom ~ SP.Map (TFldDefSym2 sch tabFrom) (Fst uncols)
  , ToStar fds
  , ToStar fdsFrom
  , ToStar n
  )
  => CQueryFields db sch t r ('FieldInfo 'FldTo n dbname ': xs) where
  getQueryFields =
    FieldTo
      (toStar @_ @n)
      (getQueryRecord @db @sch @tabFrom @recFrom)
      refs
      : getQueryFields @db @sch @t @r @xs
    where
      refs =
        zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
          (toStar @_ @cols)
          (toStar @_ @fdsFrom)
          (toStar @_ @fds)
