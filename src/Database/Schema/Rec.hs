{-# LANGUAGE UndecidableInstances    #-}
{-# LANGUAGE UndecidableSuperClasses #-}
module Database.Schema.Rec where

import Data.Kind
import Data.Singletons.Prelude as SP
import Data.Singletons.TH
import Data.Text (Text)
import Database.Schema.Def
import Util.ToStar


singletons [d|
  data FldKind = FldPlain | FldTo | FldFrom deriving (Show, Read, Eq)

  data FieldInfo' s = FieldInfo
    { fieldKind :: FldKind
    , fieldName :: s
    , fieldDbName :: s }
    deriving Show

  |]

type FieldInfoK = FieldInfo' Symbol
type FieldInfo = FieldInfo' Text

-- | instances will be generated by TH
class CFieldType (r :: Type) (n :: Symbol) where
  type TFieldType r n :: Type

-- | instances will be generated by TH
class ToStar (TRecordInfo r) => CRecordInfo r where
  type TRecordInfo r :: [FieldInfoK]

  recordInfo :: [FieldInfo]
  recordInfo = toStar @_ @(TRecordInfo r)

data QueryRecord = QueryRecord
  { tableName   :: Text
  , queryFields :: [QueryField] }
  deriving Show

data QueryRef = QueryRef
  { fromName :: Text
  , fromDef  :: FldDef
  , toName   :: Text
  , toDef    :: FldDef }
  deriving Show

data QueryField
  = FieldPlain Text Text FldDef
  | FieldTo    Text QueryRecord [QueryRef]
  | FieldFrom  Text QueryRecord [QueryRef]
  deriving Show

-- | instances will be generated by TH (with default method)
class
  (ToStar t, CQueryFields db sch t r (TRecordInfo r))
  => CQueryRecord db sch (t::Symbol) r where
  getQueryRecord :: QueryRecord
  getQueryRecord = QueryRecord {..}
    where
      tableName = toStar @_ @t
      queryFields = getQueryFields @db @sch @t @r @(TRecordInfo r)

class CTypDef sch tn => CanConvert db sch (tn::Symbol) (nullable::Bool) t

class CQueryFields db sch t r (fis :: [FieldInfoK]) where
 getQueryFields :: [QueryField]

instance CQueryFields db sch t r '[] where
  getQueryFields = []

instance
  ( CQueryFields db sch t r xs
  , CFldDef sch t dbname
  , fdef ~ TFldDef sch t dbname
  , CanConvert db sch (FdType fdef) (FdNullable fdef) (TFieldType r n)
  , ToStar n
  )
  => CQueryFields db sch t r ('FieldInfo 'FldPlain n dbname ': xs) where
  getQueryFields =
    FieldPlain (toStar @_ @n) (toStar @_ @dbname) (fldDef @sch @t @dbname)
      : getQueryFields @db @sch @t @r @xs

instance
  ( CQueryFields db sch t r xs
  , relDef ~ TRelDef sch dbname
  , tabTo ~ RdTo relDef
  , recTo ~ TFieldType r n
  , CQueryRecord db sch tabTo recTo
  , cols ~ RdCols relDef
  , ToStar cols
  , uncols ~ Unzip cols
  , CFldDefs sch t (Fst uncols)
  , CFldDefs sch tabTo (Snd uncols)
  , ToStar n
  )
  => CQueryFields db sch t r ('FieldInfo 'FldFrom n dbname ': xs) where
  getQueryFields =
    FieldFrom
      (toStar @_ @n)
      (getQueryRecord @db @sch @tabTo @recTo)
      refs
      : getQueryFields @db @sch @t @r @xs
    where
      refs =
        zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
          (toStar @_ @cols)
          (fldDefs @sch @t @(Fst uncols))
          (fldDefs @sch @tabTo @(Snd uncols))

instance
  ( CQueryFields db sch t r xs
  , relDef ~ TRelDef sch dbname
  , tabFrom ~ RdFrom relDef
  , recFrom ~ TFieldType r n
  , CQueryRecord db sch tabFrom recFrom
  , cols ~ RdCols relDef
  , ToStar cols
  , uncols ~ Unzip cols
  , CFldDefs sch t (Snd uncols)
  , CFldDefs sch tabFrom (Fst uncols)
  , ToStar n
  )
  => CQueryFields db sch t r ('FieldInfo 'FldTo n dbname ': xs) where
  getQueryFields =
    FieldTo
      (toStar @_ @n)
      (getQueryRecord @db @sch @tabFrom @recFrom)
      refs
      : getQueryFields @db @sch @t @r @xs
    where
      refs =
        zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
          (toStar @_ @cols)
          (fldDefs @sch @tabFrom @(Fst uncols))
          (fldDefs @sch @t @(Snd uncols))
