# pg-schema

Type provider from PostgreSQL. With some batteries.

## Installation

```
> git clone ...
> stack install
```

## Brief
Using this package you could

* get ~~all~~ important information from PostgreSQL DB on haskell type level
through TH
* define complex record types in accordance with schema db including referencing
and referenced data
* getting effective select query to populate such records
* ~~getting effective insert/update/delete command to save such records in db~~
(not realised yet)

A number of possible problems with db-interaction could be resolved in
compile time.

Compilation time for small database (~60 tables) is not bad
(say 10 seconds with -O0).
I suppose that is acceptable for a medium to big databases as well.

## Tutorial

We will use a table set which is described in [this file](sql/create.sql)
Many GHC-extensions should be enabled. I use the following
(maybe some of them is not necessary):
```
  AllowAmbiguousTypes
, ConstraintKinds
, DataKinds
, DeriveGeneric
, EmptyCase
, ExistentialQuantification
, FlexibleContexts
, FlexibleInstances
, FunctionalDependencies
, GADTs
, GeneralizedNewtypeDeriving
, InstanceSigs
, LambdaCase
, MultiParamTypeClasses
, OverloadedStrings
, QuasiQuotes
, RecordWildCards
, ScopedTypeVariables
, TemplateHaskell
, TupleSections
, TypeApplications
, TypeFamilies
, TypeInType
, TypeOperators
```

### Type provider

To get info from DB we should define data and use TH-function:

```
> import Database.PostgreSQL.Schema.TH
> data Sch
> mkSchema <db-connect ByteString> ''Sch "sch"
```
(where "sch" is a name of our schema in database)

Here we automatically define the following instances:

* `instance CSchema Sch`
* `instance CTabDef Sch <table_name>` for each table in schema "sch"
* `instance CRelDef Sch <constraint_name>`for each foreign key constraints
(relations) in schema "sch"
* `instance CFldDef Sch <tab_le_name> <field_name>` for each field in each
table in schema "sch"
* `instance CTypDef Sch <type_name>` for each datatype used in fields in
schema "sch"

These are instances for classes defined in module `Database.Schema.Def`:

* `CSchema` - define type-lists of table and relation names
* `CTabDef` - define `type TTabDef sch name :: TabDefK` where
```
data TypDef' s = TypDef
  { typCategory :: s
  , typElem     :: Maybe s
  , typEnum     :: [s] }
  deriving Show
```
* `CRelDef` - define `type TRelDef sch name :: RelDefK` where
```
data RelDef' s = RelDef
  { rdFrom    :: s
  , rdTo      :: s
  , rdCols    :: [(s,s)] }
  deriving Show
```
* `CFldDef` - define `type TFldDef sch tname fname :: FldDefK` where
```
data FldDef' s = FldDef
  { fdType        :: s
  , fdNullable    :: Bool
  , fdHasDefault  :: Bool }
```
* `CTypDef` - define `type TTypDef sch name :: TypDefK` where
```
data TypDef' s = TypDef
  { typCategory :: s
  , typElem     :: Maybe s
  , typEnum     :: [s] }
  deriving Show
```

All these types are promoted. On value level they are used with `s ~ Text`.
On type level they are used with `s ~ Symbol`. I use the following convention:
* `SomeType'` - some type with parameter
* `type SomeType = SomeType' Text`
* `type SomeTypeK = SomeType' Symbol`

### Record definition

To get data from DB we have to define Haskell records for db-data. It is
a regular records with single constructor. Haskell field names should correspond
to names in database. We can use renaming function which define db-name
by haskell-name but in most cases I prefer the same names.

These records could include three kinds of fields:
* fields from some table with types which can be converted to and from
database types
* fields with type of some other record corresponding to table which is
referenced from base table
* fields with type `SchemaList <Rec>` where <Rec> is record corresponding
to table which is referencing to base table (a.k.a. child table)

After creating such records we should define for them some common instances:
* `FromJSON` (to get record as JSON from db - for child tables)
* `ToJSON`
* `FromField` (to get record as field - for references)
* `ToField`
* `FromRow`
* `ToRow`
*
Usually these references should be generated by default or defined in obvious
way like `fromField = fromJSONField`, `toField = toJSONField`.

Then we should define specific instances:
* `instance CRecordInfo <record_type>`
* `instance CFieldType <record_type> <field_name>`
* `instance CQueryRecord PG <Sch> <table_name> <record_type>`

First two instances are generated by TH-function
```
> schemaRec @Sch id n
```
These instances describe record on type level classifying fields by their kinds.
These classes have no parameters which are linked to db.
But on instances generation we use our info about db-schema.

After these instances are generated we can define instance of `CQueryRecord`:
```
> instance CQueryRecord PG <Sch> <table_name> <record_type>
```
That's all. Class `CQueryRecord` has default implementation and we just have
to declare an instance. This class incapsulate many type-level constraints and
provide all necessary information about links between record and database
tables on value level.

`CQueryRecords` instance declaration checks many constraints.
Among them it checks that data can be converted from database-field to
haskell-field and vice versa. It uses instances of class `CanConvertPG` defined
in module `Database.PostgreSQL.Convert`.

NB! Class `CQueryRecord` use type parameter `PG` which is defined in module
`Database.PostgreSQL.DB`.
It provide a possibility to use the same types for other databases

### Select data from database

What can we do with all those types and instances?
We can get and check all table or field names, unique and foreign keys and so on.
Then we can get text for select-query or just run it.

PostgreSQL permit to get related data in one query utilize json-format
to pack child data. This query we can easily generate now:
```
> sql = selectText @Sch @<table_name> @<record_type>
```
where
```
selectText :: forall sch tab r. CQueryRecord PG sch tab r => Text
```
In `Database.PostgreSQL.DML.Select` defined also functions
```
selectQuery :: forall sch tab r. CQueryRecord PG sch tab r => Query

selectSch_
  :: forall sch tab r. (FromRow r, CQueryRecord PG sch tab r)
  => Connection -> IO [r]
```

`Where` clause is not supported yet.
If one need it he have to get select text and add `where` clause by hand.

This way of selecting data from database is used also on generating schema.
In module `Database.PostgreSQL.Schema.Catalog` part of structure of schema
`pg_catalog` is described.
Module `Database.PostgreSQL.Schema.Info` describe records to populate data
from `pg_catalog`. These data-records are used on TH-generation.

### DML-operations (Insert/Update/Delete)

There is no special support for DML-operations yet.
