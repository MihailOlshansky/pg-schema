{-# LANGUAGE UndecidableInstances    #-}
{-# LANGUAGE UndecidableSuperClasses #-}
module Database.Schema.Rec where

import Data.Kind
import Data.Singletons.Prelude as SP
import Data.Singletons.TH
import Data.Text (Text)
import Database.Schema.Def
import Util.ToStar


singletons [d|
  data FieldInfo' s = FieldInfo
    { fieldName :: s
    , fieldDbName :: s }
    deriving Show

  |]

type FieldInfoK = FieldInfo' Symbol
type FieldInfo = FieldInfo' Text

-- | instances will be generated by TH
class CFieldType (r :: Type) (n :: Symbol) where
  type TFieldType r n :: Type

-- | instances will be generated by TH
class ToStar (TRecordInfo r) => CRecordInfo r where
  type TRecordInfo r :: [FieldInfoK]

recordInfo :: forall r. CRecordInfo r => [FieldInfo]
recordInfo = toStar @_ @(TRecordInfo r)

data QueryRecord = QueryRecord
  { tableName   :: Text
  , queryFields :: [QueryField] }
  deriving Show

data QueryRef = QueryRef
  { fromName :: Text
  , fromDef  :: FldDef
  , toName   :: Text
  , toDef    :: FldDef }
  deriving Show

data QueryField
  = FieldPlain Text Text FldDef
  | FieldTo    Text QueryRecord [QueryRef]
  | FieldFrom  Text QueryRecord [QueryRef]
  deriving Show

-- | instances will be generated by TH (with default method)
class
  (CSchema sch, ToStar t, CQueryFields db sch t r (TRecordInfo r))
  => CQueryRecord (db::Type) (sch::Type) (t::Symbol) (r::Type) where
  getQueryRecord :: QueryRecord
  getQueryRecord = QueryRecord {..}
    where
      tableName = toStar @_ @t
      queryFields = getQueryFields @db @sch @t @r @(TRecordInfo r)

class CTypDef sch tn => CanConvert db sch (tn::Symbol) (nullable::Bool) t

class
  (CSchema sch, CTabDef sch t)
  => CQueryFields db sch t r (fis :: [FieldInfoK]) where
  getQueryFields :: [QueryField]

class CQueryFieldT (ft :: FldKind) db sch t r (fi :: FieldInfoK) where
  getQueryFieldT :: QueryField
--

instance (CSchema sch, CTabDef sch t) => CQueryFields db sch t r '[] where
  getQueryFields = []

instance
  ( CQueryFieldT (TFieldKind sch t (FieldDbName x)) db sch t r x
  , CQueryFields db sch t r xs
  , CSchema sch, CTabDef sch t )
  => CQueryFields db sch t r (x ': xs) where
  getQueryFields
    = getQueryFieldT @(TFieldKind sch t (FieldDbName x)) @db @sch @t @r @x
    : getQueryFields @db @sch @t @r @xs

instance
  ( CFldDef sch t dbname
  , fdef ~ TFldDef sch t dbname
  , CanConvert db sch (FdType fdef) (FdNullable fdef) (TFieldType r n)
  , ToStar n )
  => CQueryFieldT 'FldPlain db sch t r ('FieldInfo n dbname) where
  getQueryFieldT =
    FieldPlain (toStar @_ @n) (toStar @_ @dbname) (fldDef @sch @t @dbname)


instance
  ( relDef ~ TRelDef sch dbname
  , tabTo ~ RdTo relDef
  , recTo ~ TFieldType r n
  , CQueryRecord db sch tabTo recTo
  , cols ~ RdCols relDef
  , ToStar cols
  , uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Fst uncols)
  , fdsTo ~ SP.Map (TFldDefSym2 sch tabTo) (Snd uncols)
  , ToStar fds
  , ToStar fdsTo
  , ToStar n )
  => CQueryFieldT 'FldFrom db sch t r ('FieldInfo n dbname) where
  getQueryFieldT =
    FieldFrom
      (toStar @_ @n)
      (getQueryRecord @db @sch @tabTo @recTo)
      refs
    where
      refs =
        zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
          (toStar @_ @cols)
          (toStar @_ @fds)
          (toStar @_ @fdsTo)

instance
  ( relDef ~ TRelDef sch dbname
  , tabFrom ~ RdFrom relDef
  , recFrom ~ TFieldType r n
  , CQueryRecord db sch tabFrom recFrom
  , cols ~ RdCols relDef
  , ToStar cols
  , uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Snd uncols)
  , fdsFrom ~ SP.Map (TFldDefSym2 sch tabFrom) (Fst uncols)
  , ToStar fds
  , ToStar fdsFrom
  , ToStar n )
  => CQueryFieldT 'FldTo db sch t r ('FieldInfo n dbname) where
  getQueryFieldT =
    FieldTo
      (toStar @_ @n)
      (getQueryRecord @db @sch @tabFrom @recFrom)
      refs
    where
      refs =
        zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
          (toStar @_ @cols)
          (toStar @_ @fdsFrom)
          (toStar @_ @fds)

type AllMandatory sch t r =
  IsAllMandatory sch t (Map FieldDbNameSym0 (TRecordInfo r)) ~ 'True
